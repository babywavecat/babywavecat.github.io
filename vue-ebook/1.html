<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue原生项目研究小结 | 前端小队</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="作者：mileschao">
    
    <link rel="preload" href="/assets/css/0.styles.65edb539.css" as="style"><link rel="preload" href="/assets/js/app.ba78fd4d.js" as="script"><link rel="preload" href="/assets/js/2.65bead49.js" as="script"><link rel="preload" href="/assets/js/3.704c29b5.js" as="script"><link rel="preload" href="/assets/js/8.9dd1dffb.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.65edb539.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端小队</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">概述</a></div><div class="nav-item"><a href="/vue-ebook/" class="nav-link router-link-active">内容</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">概述</a></div><div class="nav-item"><a href="/vue-ebook/" class="nav-link router-link-active">内容</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0" style="padding-top:10px;"><p class="sidebar-heading open"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-ebook/0.html" class="sidebar-link">sharp</a></li><li><a href="/vue-ebook/1.html" aria-current="page" class="active sidebar-link">Vue原生项目研究小结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#浅显研究的话就是vue更多的是一些状态管理以及跨页面的通信-通过多重复用的组件实现代码页面。" class="sidebar-link">浅显研究的话就是vue更多的是一些状态管理以及跨页面的通信，通过多重复用的组件实现代码页面。</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#学习路径" class="sidebar-link">学习路径</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#关于v-on" class="sidebar-link">关于v-on ||@</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#v-bind" class="sidebar-link">v-bind || :</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#为什么使用props传递样式属性以及其他回调函数" class="sidebar-link">为什么使用Props传递样式属性以及其他回调函数?</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#路由规则" class="sidebar-link">路由规则</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#使用组件化方法的mint-ul" class="sidebar-link">使用组件化方法的mint-Ul</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#页面标签" class="sidebar-link">页面标签</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#代码逻辑-多页面管理-vuex" class="sidebar-link">代码逻辑（多页面管理）vuex</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#项目解析rss-reader" class="sidebar-link">项目解析RSS-READER</a></li><li class="sidebar-sub-header"><a href="/vue-ebook/1.html#如何从零开始构建一个健康的vue项目以及大型的单页面项目框架" class="sidebar-link">如何从零开始构建一个健康的vue项目以及大型的单页面项目框架</a></li></ul></li><li><a href="/vue-ebook/2.html" class="sidebar-link">直接更新技术栈</a></li><li><a href="/vue-ebook/3.html" class="sidebar-link">babyshark养成</a></li></ul></section></li><li><section class="sidebar-group depth-0" style="padding-top:;"><p class="sidebar-heading"><span>后记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue-ebook/99.html" class="sidebar-link">相关资源</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue原生项目研究小结"><a href="#vue原生项目研究小结" class="header-anchor">#</a> Vue原生项目研究小结</h1> <h3 id="在vue原生项目中。组件的应用更广泛而且页面结构更加复杂-路由-以及自定义的内容逻辑。"><a href="#在vue原生项目中。组件的应用更广泛而且页面结构更加复杂-路由-以及自定义的内容逻辑。" class="header-anchor">#</a> 在Vue原生项目中。组件的应用更广泛而且页面结构更加复杂，路由，以及自定义的内容逻辑。</h3> <p>页面耦合逻辑</p> <p>然后之前有做过微信小程序的页面分析，关于vue的页面布局如下</p> <div class="language- extra-class"><pre class="language-text"><code>├── build                                       // webpack配置文件，
├── config                                      // 项目打包路径。阅读配置手册进行配置
├── elm                                         // 上线项目文件，放在服务器即可正常访问
├── src                                         // 源码目录
│   ├── components                              // 组件||通用组件，购物车，列表，评价等。
│   ├── config                                  // 基本配置||rem转换，baseUrl,处理参数
│   ├── page									// pages页面|页面内的逻辑
│   ├── router									// 路由配置,说明所有页面的路径
│   ├── service                                 // 数据交互统一调配||用接口拿数据
│   ├── store                                   // vuex的状态管理????虽然暂时用不到
│  	├── style  									// 样式文件目录
│   ├── App.vue                                 // 页面入口文件||组件在各个page的正确引用	
│   └── main.js                                 // 程序入口文件，加载各种公共组件
├── favicon.ico                                 // 图标
├── index.html                                  // 入口html文件
</code></pre></div><h2 id="浅显研究的话就是vue更多的是一些状态管理以及跨页面的通信-通过多重复用的组件实现代码页面。"><a href="#浅显研究的话就是vue更多的是一些状态管理以及跨页面的通信-通过多重复用的组件实现代码页面。" class="header-anchor">#</a> 浅显研究的话就是vue更多的是一些状态管理以及跨页面的通信，通过多重复用的组件实现代码页面。</h2> <h1 id="vue-内容详细比较"><a href="#vue-内容详细比较" class="header-anchor">#</a> Vue 内容详细比较</h1> <h2 id="学习路径"><a href="#学习路径" class="header-anchor">#</a> 学习路径</h2> <div class="language- extra-class"><pre class="language-text"><code>|_____v-on//v-bind[√]
|
|_____组件基础，事件处理[√]
|
|_____上手向(教程)||计算属性，侦听属性对于wxmp的比较
|
|_____生产代码中校对的问题以及组件复用
|
|_____特殊处理，常见实例方法属性||$emit，$mount
|
|_____API向学习||全局API，全局配置，内置组件，指令||VUEX，vue-router,vue-cli
|
|_____cookbook以及风格指南


</code></pre></div><h2 id="关于v-on"><a href="#关于v-on" class="header-anchor">#</a> 关于v-on ||@</h2> <p>首先就是@，对于绑定的操作之外，v-on更多的支持了键盘修饰符的操作，如key-up等操作。以及一些防止事假冒泡的操作内容。@click.stop.甚至可以绑定一个动态事件</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 动态事件 (2.6.0+) --&gt;
&lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 内联语句 --&gt;
&lt;button v-on:click=&quot;doThat('hello', $event)&quot;&gt;&lt;/button&gt;
&lt;!-- 点击回调只会触发一次 --&gt;
&lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 对象语法 (2.4.0+) --&gt;
&lt;button v-on=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&gt;&lt;/button&gt;

</code></pre></div><h3 id="在子组件上监听自定义事件-当子组件触发-my-event-时将调用事件处理器"><a href="#在子组件上监听自定义事件-当子组件触发-my-event-时将调用事件处理器" class="header-anchor">#</a> 在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：</h3> <div class="language- extra-class"><pre class="language-text"><code>&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;

&lt;!-- 内联语句 --&gt;
&lt;my-component @my-event=&quot;handleThis(123, $event)&quot;&gt;&lt;/my-component&gt;

&lt;!-- 组件中的原生事件 --&gt;
&lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;


</code></pre></div><h3 id="事件处理器"><a href="#事件处理器" class="header-anchor">#</a> <a href="https://cn.vuejs.org/v2/guide/events.html" target="_blank" rel="noopener noreferrer">事件处理器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;button v-on:click=&quot;warn('Form cannot be submitted yet.', $event)&quot;&gt;
  Submit
&lt;/button&gt;

methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) event.preventDefault()
    alert(message)
  }
}
</code></pre></div><h3 id="组件基础"><a href="#组件基础" class="header-anchor">#</a> <a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener noreferrer">组件基础<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <h3 id="通过-prop-向子组件传递数据"><a href="#通过-prop-向子组件传递数据" class="header-anchor">#</a> <a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener noreferrer">通过 Prop 向子组件传递数据<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>尚不是很理解</p> <h2 id="v-bind"><a href="#v-bind" class="header-anchor">#</a> v-bind || :</h2> <p>动态绑定多个特性以及组件prop到表达式</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;
&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;
&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;
&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;
</code></pre></div><h2 id="为什么使用props传递样式属性以及其他回调函数"><a href="#为什么使用props传递样式属性以及其他回调函数" class="header-anchor">#</a> 为什么使用Props传递样式属性以及其他回调函数?</h2> <p>在页面和组件中，组件的复用相当频繁，所以将一些需要的组件属性，定义成prop。
然后在子组件内定义数据类型以及默认值，在父组件内获取以及传递值。</p> <p>所以所有的prop都是单项数据流的。</p> <div class="language- extra-class"><pre class="language-text"><code>所有的prop都使得其父子prop之间形成了一个单向下行绑定：父级prop的更新会向下流动到子组件
中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。


父组件在调用子组件时用v-on把事件传给子组件，子组件用this.$emit调用父组件传过来的事件。
</code></pre></div><h3 id="绑定class-active-isactive-以及绑定props子父组件传参"><a href="#绑定class-active-isactive-以及绑定props子父组件传参" class="header-anchor">#</a> 绑定class  {active : isActive},以及绑定props子父组件传参</h3> <p>·在对象当中，CSS 的属性名要用驼峰式表达：fontSize解析成font-size</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>licenses-button<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:disabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>disabled<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylecss<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>callLicenses<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{keyText}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

props: {
    stylecss: { //输入框样式
    type: Object
},
}

//多个动态绑定的样式
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>static<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ active: isActive, <span class="token punctuation">'</span>text-danger<span class="token punctuation">'</span>: hasError }<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

data: {
  isActive: true,
  hasError: false
}
//结果渲染为
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>static active<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

</code></pre></div><h2 id="路由规则"><a href="#路由规则" class="header-anchor">#</a> 路由规则</h2> <h3 id="定义-component"><a href="#定义-component" class="header-anchor">#</a> 定义 component</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">reportList</span> <span class="token operator">=</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/pages/reportList/'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'home'</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="定义路由规则"><a href="#定义路由规则" class="header-anchor">#</a> 定义路由规则</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code>routes<span class="token operator">:</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span>    path<span class="token operator">:</span><span class="token string">'/'</span><span class="token punctuation">,</span>    name<span class="token operator">:</span><span class="token string">'reportList'</span><span class="token punctuation">,</span>    redirect<span class="token operator">:</span><span class="token string">'/reportList'</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span>    
</code></pre></div><h3 id="使用"><a href="#使用" class="header-anchor">#</a> 使用</h3> <div class="language- extra-class"><pre class="language-text"><code>   &lt;div id=&quot;app&quot;&gt;        &lt;h1&gt;Hello VueRouter&lt;/h1&gt;        &lt;p&gt;            &lt;!-- 使用 router-link 组件来导航. --&gt;            &lt;!-- 通过传入 `to` 属性指定链接. --&gt;            &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;            &lt;!-- 属性 `to` 对应生成  `&lt;a&gt;` 标签的 `href` 属性--&gt;            &lt;router-link to=&quot;/foo&quot;&gt;Foo&lt;/router-link&gt;            &lt;router-link to=&quot;/bar&quot;&gt;Bar&lt;/router-link&gt;        &lt;/p&gt;        &lt;!--路由匹配的组件在此处渲染--&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;
</code></pre></div><h2 id="使用组件化方法的mint-ul"><a href="#使用组件化方法的mint-ul" class="header-anchor">#</a> 使用组件化方法的mint-Ul</h2> <h2 id="页面标签"><a href="#页面标签" class="header-anchor">#</a> 页面标签</h2> <h3 id="按需加载"><a href="#按需加载" class="header-anchor">#</a> 按需加载</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token punctuation">{</span><span class="token class-name">Header</span><span class="token punctuation">,</span><span class="token class-name">Toast</span><span class="token punctuation">,</span><span class="token class-name">Field</span><span class="token punctuation">,</span><span class="token class-name">Button</span><span class="token punctuation">,</span><span class="token class-name">Indicator</span><span class="token punctuation">}</span> from <span class="token string">'mint-ui'</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="页面公用方法在main-js中引入"><a href="#页面公用方法在main-js中引入" class="header-anchor">#</a> 页面公用方法在main.js中引入</h3> <p>goback&amp;&amp;tourl等</p> <p>其他组件定义可以在components内自定义名称</p> <h2 id="代码逻辑-多页面管理-vuex"><a href="#代码逻辑-多页面管理-vuex" class="header-anchor">#</a> 代码逻辑（多页面管理）vuex</h2> <p>实际上的使用还不是很清楚</p> <p>大概就是放置了五个原生方法，然后组件通过mapState函数进行使用</p> <h4 id="mapstate辅助方法"><a href="#mapstate辅助方法" class="header-anchor">#</a> mapState辅助方法</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    computed<span class="token operator">:</span> <span class="token function">mapState</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token function-variable function">count</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span>        countAlias<span class="token operator">:</span> <span class="token string">'count'</span><span class="token punctuation">,</span>    <span class="token comment">// 别名 `count` 等价于 state =&gt; state.count    })}</span>
</code></pre></div><p>其他同时也可以放一下公用方法</p> <h3 id="关于state、getter、muataion、action、module的作用问题"><a href="#关于state、getter、muataion、action、module的作用问题" class="header-anchor">#</a> 关于State、Getter、Muataion、Action、Module的作用问题</h3> <h4 id="getter"><a href="#getter" class="header-anchor">#</a> Getter</h4> <div class="language- extra-class"><pre class="language-text"><code>如果我们需要对state对象进行做处理计算，如下：computed: {    doneTodosCount () {        return this.$store.state.todos.filter(todo =&gt; todo.done).length    }}如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数。这样是很没有效率的事情，当这个处理过程更改了，还有在多个组件中进行同样的更改，这就更加不易于维护。Vuex中getters对象，可以方便我们在store中做集中的处理。Getters接受state作为第一个参数：const store = new Vuex.Store({  state: {    todos: [      { id: 1, text: '...', done: true },      { id: 2, text: '...', done: false }    ]  },  getters: {    doneTodos: state =&gt; {      return state.todos.filter(todo =&gt; todo.done)    }  }})在Vue中通过store.getters对象调用。computed: {  doneTodos () {    return this.$store.getters.doneTodos  }}Getter也可以接受其他getters作为第二个参数：getters: {  doneTodos: state =&gt; {      return state.todos.filter(todo =&gt; todo.done)  },  doneTodosCount: (state, getters) =&gt; {    return getters.doneTodos.length  }}
</code></pre></div><p>就是在getter里面是一些计算属性的公用方法，通过在vuex里面的状态注册之后可以进行所有页面的访问引用，完成组件化的思想以及实现。
与一般的公用方法不同的是，getter的效率更高而且有一些特定方式访问，并且可以多个参数进行调用。</p> <h4 id="mapgetters辅助函数"><a href="#mapgetters辅助函数" class="header-anchor">#</a> <a href="https://juejin.im/entry/58cb4c36b123db00532076a2" target="_blank" rel="noopener noreferrer">mapGetters辅助函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>略过</p> <h4 id="mutations"><a href="#mutations" class="header-anchor">#</a> Mutations</h4> <p>vuex中唯一用来更改state中的状态的方法</p> <p>每一个mutation都有一个事件类型type和一个回调函数handler</p> <div class="language- extra-class"><pre class="language-text"><code>const store = new Vuex.Store({  state: {    count: 1  },  mutations: {    increment (state) {      // 变更状态      state.count++    }  }})
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>调用mutation，需要通过store.commit方法调用mutation type：store.commit('increment')
</code></pre></div><h5 id="payload-提交载荷"><a href="#payload-提交载荷" class="header-anchor">#</a> Payload 提交载荷</h5> <p>也可以向store.commit传入第二参数，也就是mutation的payload:</p> <div class="language- extra-class"><pre class="language-text"><code>mutaion: {    increment (state, n) {        state.count += n;    }}store.commit('increment', 10);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>不例外，mutations也有映射函数mapMutations，帮助我们简化代码，使用mapMutations辅助函数将组件中的methods映射为store.commit调用。import { mapMutations } from 'vuex'export default {  // ...  methods: {    ...mapMutations([      'increment' // 映射 this.increment() 为 this.$store.commit('increment')    ]),    ...mapMutations({      add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')    })  }}注 Mutations必须是同步函数。如果我们需要异步操作，Mutations就不能满足我们需求了，这时候我们就需要Actions了
</code></pre></div><h3 id="action"><a href="#action" class="header-anchor">#</a> Action</h3> <p>分发 Action
Action 通过 store.dispatch 方法触发：</p> <div class="language- extra-class"><pre class="language-text"><code>store.dispatch('increment') mutation 必须同步执行,而action 内部执行异步操作：actions: {  incrementAsync ({ commit }) {    setTimeout(() =&gt; {      commit('increment')    }, 1000)  }}
</code></pre></div><h3 id="vuex独立模块"><a href="#vuex独立模块" class="header-anchor">#</a> VueX独立模块</h3> <p>如果想要独立store中的其他方法，也可以通过创建index.js引入相应文件进行</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue'import Vuex from 'vuex'import mutations from './mutations'import actions from './action'import getters from './getters'
</code></pre></div><p>最后将接口暴露出来，进行调用。state还是不变，在index.js中进行声明。</p> <h3 id="其他内容"><a href="#其他内容" class="header-anchor">#</a> 其他内容</h3> <p><a href="https://segmentfault.com/a/1190000018263418" target="_blank" rel="noopener noreferrer">前端性能优化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://my.oschina.net/u/2331760/blog/468672?p=%7B%7BcurrentPage+1%7D%7D" target="_blank" rel="noopener noreferrer">立即执行函数与闭包<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.cnblogs.com/wangfupeng1988/p/3994065.html" target="_blank" rel="noopener noreferrer">理解闭包<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://segmentfault.com/a/1190000018634744" target="_blank" rel="noopener noreferrer">前端面试题 VUE<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.im/post/5c64d15d6fb9a049d37f9c20" target="_blank" rel="noopener noreferrer">前端interview精华<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.im/post/5c970d16f265da612d634475" target="_blank" rel="noopener noreferrer">小程序实现原理解析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="项目解析rss-reader"><a href="#项目解析rss-reader" class="header-anchor">#</a> 项目解析<a href="https://github.com/mrgodhani/rss-reader/releases" target="_blank" rel="noopener noreferrer">RSS-READER<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>学习目的：vue的代码规范以及国外的技术栈差别</p> <p>生命周期函数写在main.vue里面</p> <p>组件方法不写在组件内，this.$store代理</p> <h2 id="如何从零开始构建一个健康的vue项目以及大型的单页面项目框架"><a href="#如何从零开始构建一个健康的vue项目以及大型的单页面项目框架" class="header-anchor">#</a> 如何从零开始构建一个健康的vue项目以及大型的单页面项目框架</h2> <h3 id="针对简单的小型单页面项目"><a href="#针对简单的小型单页面项目" class="header-anchor">#</a> 针对简单的小型单页面项目</h3> <p>(对比小程序)</p> <p>首先可以不需要很多公用方法的封装以及其他资源的引用，特别是vueX等状态管理器，直接在组件内运用相关的计算方法即可。不需要考虑组件复用以及其他逻辑。路由等也不需要考虑的很复杂。</p> <p>小程序，很多内容可以直接不用考虑，只需要封装一些简单的请求方法或者是公用的数据处理方法。
像是对于对象，数组的公用处理方法，ajax请求，API接口。
其他只需要关注页面本身的逻辑即可，
由于vue本身的资源丰富，所以可以使用的组将更多，复杂度较小程序也更高。</p> <div class="language- extra-class"><pre class="language-text"><code>this.$store.commit('stateFn',obj); //状态管理  // 将需要更新的值传到vuex,然后通过mutation方法(vuex中唯一用来更改state中的状态的方法)更改目标值
</code></pre></div><p>复杂的问题在于，很多请求的实现都是用了许许多多不同的组件实现的。而这些组件之中又有着不同的依赖，部分也都是相互依赖的modules。
像是axios，h5_native_proxy(自定义),proxy(?)等</p> <p>使用辅助函数mapstate的作用即是
当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。</p> <p>通过状态管理辅助函数完成对于单一状态树下的模块化管理</p> <h3 id="针对大型的多页面项目-elm"><a href="#针对大型的多页面项目-elm" class="header-anchor">#</a> 针对大型的多页面项目(elm)</h3> <p>因为页面数量众多，相应的，引入的组件也更多，对于状态的操作也更频繁。页面之间的跳转逻辑颗牙哟独立出来，同时，考虑代码的维护性
很多功能并不需要写在store中，直接在页面内使用即可。</p> <p>而且一般的页面逻辑并不复杂，都是一些简单方法的调用，getData，传参，数据处理，组件页面因为涉及到复用而更加繁琐。</p> <p>大型项目的vuex store写法即是，将一些types单独暴露在其他的js中，然后在需要引入的地方
正确引入，然后将其用标准语法</p> <h4 id="again-更改-vuex-的-store-中的状态的唯一方法是提交-mutation。"><a href="#again-更改-vuex-的-store-中的状态的唯一方法是提交-mutation。" class="header-anchor">#</a> again 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。</h4> <div class="language- extra-class"><pre class="language-text"><code> increment (state) {      // 变更状态      state.count++    }以上的标准写法，过渡成  [INIT_BUYCART](state) {    ……………………表达式},这种写法是 ES2015 风格的计算属性命名功能来使用一个常量作为函数名这个称之为type，意义就是唤醒上面的  handler,store.commit('increment')为store.commit 传入额外的参数，即 mutation 的 载荷（payload）store.commit('increment', {  amount: 10})
</code></pre></div><h4 id="vue使用mixin生命全局变量以及定义一些错误展示信息"><a href="#vue使用mixin生命全局变量以及定义一些错误展示信息" class="header-anchor">#</a> vue使用mixin生命全局变量以及定义一些错误展示信息</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">*</span> Vueprototype<span class="token punctuation">.</span>jsconst methods <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            nodata<span class="token operator">:</span> <span class="token string">'nodataView'</span><span class="token punctuation">,</span>            errordefaultImg<span class="token operator">:</span> <span class="token string">'this.src=&quot;'</span> <span class="token operator">+</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;../image/fail.png&quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'&quot;'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    components<span class="token operator">:</span> <span class="token punctuation">{</span>        nodataView<span class="token operator">:</span> <span class="token punctuation">{</span>            template<span class="token operator">:</span> <span class="token string">'&lt;div class=&quot;nodata&quot;&gt;&lt;img src=&quot;'</span> <span class="token operator">+</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;../image/nodata.png&quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'&quot; width=&quot;222&quot;/&gt;&lt;p&gt;暂无数据&lt;/p&gt;&lt;/div&gt;'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    methods<span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="vue3-0-过渡"><a href="#vue3-0-过渡" class="header-anchor">#</a> [Vue3.0 过渡](</h4></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/vue-ebook/0.html" class="prev">
          sharp
        </a></span> <span class="next"><a href="/vue-ebook/2.html">
          直接更新技术栈
        </a>
        →
      </span></p></div>  <div class="gitalk-container theme-default-content"><div id="gitalk-container" class="content"></div></div></main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ba78fd4d.js" defer></script><script src="/assets/js/2.65bead49.js" defer></script><script src="/assets/js/3.704c29b5.js" defer></script><script src="/assets/js/8.9dd1dffb.js" defer></script>
  </body>
</html>
